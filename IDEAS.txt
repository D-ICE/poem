
L'ecriture de polaire c'est ESPERADO qui fixe la norme.
Question: on pourrait avoir des convertisseurs de polaires thirdparty... Dans ce cas comment on gere le writer ?



Avoir un depot tierce
    -> DONE c'est celui dans lequel on est

Pour chaque version de format de fichier de polaire, on doit avoir un fichier json qui specifie les noms de variable qu'on peut avoir
    -> DONE pour v1

Il faut un code qui lise une polaire, recupere la version de la polaire et check si chaque champ est licite point de vue json correspondant a la version
    -> TODO: implementer dans ESPERADO l'ecriture de version de polaire

L'utilisation de regex semble naturelle
    -> a implementer dans les cles

Le code peut soit rejeter (erreur), soit alerter
    ->TODO

Il faut que le code soit appelable depuis C++ et python
    ->TODO

Il est necessaire d'avoir de la retrocompatilibte
    ->TODO avec les differentes versions de json "scheme"

Les interfaces de lecture des polaires devraient toujours reposer sur la toute derniere version par defaut
    -> TODO: il s'agit donc quand meme de mettre a jour l'outil de lecture
         ne doit-il pas etre dans un autre depot encore ?

Si on leur donne une polaire de version inférieure, elles doivent pouvoir mapper entre les noms d'ancienne version et les nouveaux
    -> TODO: avec le systeme de json

Les mappings inter version devraient être encodés dans les fichiers json de spec de version
    -> OK engage

Dans le code de lecture, le mapping de nom devrait être effectué au chargement, une seule fois.
    -> TODO

A chaque nouvelle version, on a un nouveau fichier json qui peut pointer vers le nom utilisé immédiatement précédent
	genre {old <- new}
	-> TODO: a reflechir encore
	
Le versionning ne doit pas se faire sur du semantic versionning mais sur un entier simple
    -> OK engage

Pour les polaires déjà générée, il faudrait un outil d'upgrade' de version de fichier .nc a la derniere version
    -> TODO

Voir à trouver une lib qui permette aussi d'inférer un nouveau nom par rapport à un ancien pour aider
    -> On pourrait faire du fuzzy check de string sur les variables
          https://stackoverflow.com/questions/70236962/how-do-i-find-the-closest-match-to-a-string-key-within-a-c-map
          https://stackoverflow.com/questions/5859561/getting-the-closest-string-match

Voir à avoir une syntaxe de new, optional, deprecated etc... dans les fichiers json

Le code de lecture devrait etre capable de gerer ces codes
    -> ???


Les outils de check devraient tourner à chaque lecture de polaire
    -> TODO


===========================
SLICING
===========================

La classe Polar devrait mettre à disposition une méthode de slice.

Exemple:
    Polar<5> avec un DimensionPointSet<5> qui est [STW, TWS, TWA, WA, Hs]

    polar.slice({STW: 10, TWS: 20}) -> Polar<3> avec un DimensionPointSet<3> qui est [TWA, WA, Hs]

    ou alors on peut aussi le faire par étape

    polar.slice({STW: 10, TWS: 2°}) -> polar<5> qui conserve le même DimensionPointSet mais avec du singleton pour STW et TWS
        et possibilite d'obtenir la polaire  Polar<3> en appelant un polar.squeeze

    On peut certainement finalement proposer les 3
    * slice
    * squeeze
    * sslice (slice & squeeze)

    1 - On fournit un dictionnaire std::map<std::string, std::vector<double>> à slice.
    2 -




